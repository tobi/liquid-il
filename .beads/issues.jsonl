{"id":"liquid-il-121","title":"Optimization policy \u0026 pass ordering","description":"Design and implement optimization policy infrastructure to control pass ordering, iteration limits, and optimization levels (-O0, -O1, -O2). Define which passes run at each level and handle pass dependencies.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:09:44.420098-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:44.420098-05:00"}
{"id":"liquid-il-1cr","title":"Value numbering optimization pass","description":"Implement global value numbering (GVN) to identify and eliminate redundant computations across the instruction stream. This enables CSE (common subexpression elimination) by assigning canonical numbers to values with identical computations.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:09:39.58975-05:00","created_by":"tobi","updated_at":"2026-01-13T11:27:46.129472-05:00","closed_at":"2026-01-13T11:27:46.129472-05:00","close_reason":"Implemented value_numbering optimization pass that caches repeated FIND_VAR and FIND_VAR_PATH within basic blocks. Also fixed control_flow_boundary? to include INCREMENT/DECREMENT operations."}
{"id":"liquid-il-3kf","title":"Ruby compiler: handle WRITE_VAR opcode","description":"The fuse_write_var pass (pass 20) creates WRITE_VAR opcodes that ruby_compiler.rb doesn't handle. Need to add a handler that generates efficient Ruby code for WRITE_VAR, similar to how FIND_VAR + WRITE_VALUE is handled.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-14T21:10:45.165-05:00","created_by":"tobi","updated_at":"2026-01-14T21:14:09.325061-05:00","closed_at":"2026-01-14T21:14:09.325061-05:00","close_reason":"Closed"}
{"id":"liquid-il-44y","title":"Optimization policy framework","description":"Create a policy/configuration framework to control which optimizations run.\n\n**Goals:**\n- Allow enabling/disabling individual passes\n- Support optimization levels (O0, O1, O2, O3)\n- Enable debugging specific pass behavior\n- Control tradeoffs (compile time vs runtime, code size vs speed)\n\n**Policy decisions:**\n- O0: No optimization (current default without optimize: true)\n- O1: Fast, safe optimizations (const folding, dead code removal)\n- O2: All current passes (default with optimize: true)\n- O3: Aggressive (inlining, unrolling, may increase code size)\n\n**Implementation:**\n- OptimizationPolicy class with pass enable/disable\n- Pass ordering/dependency management\n- Per-pass configuration (e.g., unroll threshold, inline size limit)\n- Debug mode to dump IL after each pass\n\n**Integration:**\n- Wrap existing optimize() method\n- New API: compile(optimization_level: 2)\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T11:07:38.460196-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.864429-05:00","closed_at":"2026-01-13T11:09:58.864429-05:00","close_reason":"duplicate - superseded by new issues"}
{"id":"liquid-il-4mg","title":"make rake spec/matrix work 100%, especially the optimized il","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-13T13:45:02.631125-05:00","created_by":"tobi","updated_at":"2026-01-13T13:45:02.631125-05:00"}
{"id":"liquid-il-4pg","title":"Dead store elimination optimization pass","description":"Implement dead store elimination to remove stores whose values are never read before being overwritten or when the stored location goes out of scope. Requires effect analysis to be safe.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:09:42.832394-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:42.832394-05:00","dependencies":[{"issue_id":"liquid-il-4pg","depends_on_id":"liquid-il-hpb","type":"blocks","created_at":"2026-01-13T11:09:49.952834-05:00","created_by":"tobi"}]}
{"id":"liquid-il-4v3","title":"Improve error hierarchy: add ParseError and RenderError types","description":"Currently catching StandardError in render methods to handle drop method errors, which is too broad. Should have:\n\n- ParseError (for lexer/parser issues) - already have SyntaxError\n- RenderError (for runtime issues during rendering) - currently using RuntimeError\n- Filter errors from liquid gem come as Liquid::StandardError with 'Liquid error: ' prefix\n\nThe clean_error_message helper strips 'Liquid error: ' prefix as a workaround. Better solution would be to wrap all external errors in our own error types at the boundary.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-14T14:54:41.289339-05:00","created_by":"tobi","updated_at":"2026-01-14T14:54:51.237817-05:00"}
{"id":"liquid-il-6hr","title":"Loop unrolling pass","description":"Implement loop unrolling for small, bounded for loops.\n\n**Target loops:**\n- FOR loops with statically known iteration count\n- Small iteration count (e.g., ≤4 iterations)\n- No early exits (break) \n\n**Benefits:**\n- Eliminates loop overhead (FOR_INIT, FOR_NEXT, FOR_END)\n- Enables further optimizations on unrolled body\n- Particularly valuable for small array iterations\n\n**Algorithm:**\n- Detect FOR_INIT with constant range or small array\n- Duplicate loop body n times with loop variable substituted\n- Remove FOR_INIT/FOR_NEXT/FOR_END instructions\n\n**Considerations:**\n- forloop object must be correctly emulated\n- Code size increase vs performance tradeoff\n- Consider unroll factor configuration\n\n**Integration:**\n- Add as optimization pass in compiler.rb\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-13T11:07:13.677155-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.877594-05:00","closed_at":"2026-01-13T11:09:58.877594-05:00","close_reason":"duplicate - superseded by new issues"}
{"id":"liquid-il-85q","title":"Value numbering pass","description":"Implement global value numbering (GVN) to identify equivalent computations and eliminate redundant ones.\n\n**Core algorithm:**\n- Assign unique value numbers to expressions\n- Expressions with same inputs get same value number\n- Replace redundant computations with cached values\n\n**Key patterns to optimize:**\n- Repeated FIND_VAR for same variable → reuse\n- Repeated CALL_FILTER with same inputs → reuse  \n- Repeated arithmetic expressions → reuse\n\n**Implementation:**\n- Build value number table during forward pass\n- Track which temps hold which value numbers\n- Replace redundant expressions with LOAD_TEMP\n\n**Dependencies:**\n- Effect analysis (to know which operations are pure)\n\n**Integration:**\n- Add as optimization pass in compiler.rb\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:06:43.305707-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.876192-05:00","closed_at":"2026-01-13T11:09:58.876192-05:00","close_reason":"duplicate - superseded by new issues","dependencies":[{"issue_id":"liquid-il-85q","depends_on_id":"liquid-il-o8d","type":"blocks","created_at":"2026-01-13T11:07:43.677918-05:00","created_by":"tobi"}]}
{"id":"liquid-il-87w","title":"Global linear scan register allocator","description":"Implement global linear scan register allocation for the RubyCompiler backend. Assign virtual registers to physical locals/temps, minimizing spills and reloads. Requires liveness analysis across the full instruction stream.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-13T11:09:45.008921-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:45.008921-05:00"}
{"id":"liquid-il-auc","title":"Store \u0026 load forwarding optimization pass","description":"Implement store-to-load forwarding to replace loads with the value of a preceding store to the same location when no intervening writes exist. Eliminates redundant memory access patterns.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:09:42.251854-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:42.251854-05:00","dependencies":[{"issue_id":"liquid-il-auc","depends_on_id":"liquid-il-hpb","type":"blocks","created_at":"2026-01-13T11:09:50.009533-05:00","created_by":"tobi"}]}
{"id":"liquid-il-bob","title":"Loop unrolling optimization pass","description":"Implement loop unrolling for for-loops with statically known iteration counts. Unroll small constant-bound loops to eliminate loop overhead and enable further optimizations on the unrolled body.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:09:40.893057-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:40.893057-05:00"}
{"id":"liquid-il-cih","title":"Skip state machine for linear templates","description":"**Problem:** Even simple templates like `{{ name }}` generate a full state machine with `while true; case __pc__; when 0; ...` pattern, adding overhead for the common case.\n\n**Proposed improvement:** Detect templates without control flow (no jumps/labels) and generate straight-line code instead:\n\n```ruby\n# Current\n__pc__ = 0\nwhile true\n  case __pc__\n  when 0\n    __output__ \u003c\u003c \"Hello \"\n    __output__ \u003c\u003c (__v__ = __scope__.lookup(\"name\"); ...)\n    break\n  else\n    break\n  end\nend\n\n# Proposed\n__output__ \u003c\u003c \"Hello \"\n__output__ \u003c\u003c (__v__ = __scope__.lookup(\"name\"); ...)\n```\n\n**Impact:** Eliminate dispatch overhead for ~60% of templates (those without control flow).\n\n**Profile evidence:** State machine dispatch visible in hot path.\n\n**Implementation notes:**\n- Add IL analysis pass to detect linear templates (no JUMP, LABEL, etc.)\n- Add alternate code generation path in ruby_compiler.rb\n- Benchmark before/after","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-14T19:21:08.312101-05:00","created_by":"tobi","updated_at":"2026-01-14T19:35:06.341052-05:00","closed_at":"2026-01-14T19:35:06.341052-05:00","close_reason":"Feature already implemented - generate_ruby_body correctly uses generate_straight_line for linear templates (no jumps/control flow). Fixed two unrelated bugs found during investigation: added missing find_max_temp_index method and initialized @hoist_temp_counter.","labels":["ralph"]}
{"id":"liquid-il-cn5","title":"Compiled: render for loop doesn't iterate over Drops with each","description":"In ruby_compiler.rb around line 873-885, the 'for' loop handling only iterates if __for_coll__.is_a?(Array). But Drops that implement 'each' (like TestEnumerable) are not iterated - they're just passed as-is. Need to check if the collection responds to :each and iterate accordingly.","status":"closed","priority":1,"issue_type":"bug","owner":"tobi@shopify.com","created_at":"2026-01-14T21:20:12.668629-05:00","created_by":"Tobi Lutke","updated_at":"2026-01-14T21:46:32.782211-05:00","closed_at":"2026-01-14T21:46:32.782211-05:00","close_reason":"Fixed render for loop iteration in ruby_compiler.rb. Changed generate_partial_call to match VM semantics: Arrays iterate, Ranges iterate for render (not include), enumerable Drops iterate, nil renders once with named args only, scalars render once with that value. Also fixed render with when implicit value is nil - named args now take precedence for isolated render. Reduced test failures from 21 to 6 (remaining failures are unrelated error message formatting issues)."}
{"id":"liquid-il-e15","title":"VM interpreter optimization: eliminate per-instruction overhead","status":"open","priority":4,"issue_type":"feature","created_at":"2026-01-14T20:50:40.284062-05:00","created_by":"tobi","updated_at":"2026-01-14T22:18:25.544181-05:00"}
{"id":"liquid-il-e5q","title":"Escape analysis and scalar replacement pass","description":"Implement escape analysis to determine if objects escape their defining scope, enabling scalar replacement.\n\n**Escape analysis:**\n- Track if hash/array values escape (passed to filters, partials, output)\n- Non-escaping aggregates can be decomposed into scalars\n\n**Scalar replacement:**\n- Replace non-escaping BUILD_HASH with individual scalar values\n- Replace hash[key] lookups with direct scalar access\n- Eliminates hash allocation and lookup overhead\n\n**Key patterns:**\n- {% assign h = 'a' | something | hash_filter %}\n- If h only used locally with known keys, replace with scalars\n\n**Considerations:**\n- Liquid hashes are relatively rare - measure impact\n- Must handle dynamic key access conservatively\n\n**Dependencies:**\n- Effect analysis (to track escaping through filters)\n\n**Integration:**\n- Add as optimization pass in compiler.rb\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:07:05.967061-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.872355-05:00","closed_at":"2026-01-13T11:09:58.872355-05:00","close_reason":"duplicate - superseded by new issues","dependencies":[{"issue_id":"liquid-il-e5q","depends_on_id":"liquid-il-o8d","type":"blocks","created_at":"2026-01-13T11:07:43.868263-05:00","created_by":"tobi"}]}
{"id":"liquid-il-enp","title":"Inlining pass","description":"Implement inlining for render/include partials when beneficial.\n\n**Target scenarios:**\n- Small partials (below size threshold)\n- Frequently called partials\n- Partials with constant arguments\n\n**Benefits:**\n- Eliminates partial call overhead\n- Enables cross-partial optimization\n- Constant propagation into partial body\n\n**Algorithm:**\n- Identify RENDER_PARTIAL/INCLUDE_PARTIAL with resolvable template\n- If partial small enough, inline its IL\n- Rename labels to avoid conflicts\n- Adjust scope handling (PUSH_SCOPE/POP_SCOPE)\n\n**Considerations:**\n- Must handle recursive partials (don't inline)\n- Variable scoping differences between render vs include\n- Code size increase tradeoff\n- May need partial lookup at compile time\n\n**Note:** CONST_RENDER/CONST_INCLUDE already exist - this extends that\n\n**Integration:**\n- Add as optimization pass in compiler.rb\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:07:21.324028-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.871057-05:00","closed_at":"2026-01-13T11:09:58.871057-05:00","close_reason":"duplicate - superseded by new issues"}
{"id":"liquid-il-ftc","title":"Store and load forwarding pass","description":"Implement store-to-load and load-to-load forwarding to eliminate redundant memory operations.\n\n**Store-to-load forwarding:**\n- When loading a value just stored, use the stored value directly\n- Pattern: ASSIGN x, val; ... FIND_VAR x → use val directly\n\n**Load-to-load forwarding:**  \n- When loading same variable twice, reuse first load\n- Pattern: FIND_VAR x; ... FIND_VAR x → LOAD_TEMP\n\n**Key considerations:**\n- Must track aliasing (what could have modified the variable)\n- Invalidate on: PUSH_SCOPE, POP_SCOPE, CALL_FILTER with side effects\n- Respect control flow boundaries\n\n**Dependencies:**\n- Effect analysis (to know what modifies variables)\n\n**Integration:**\n- Add as optimization pass in compiler.rb\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:06:51.117157-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.874907-05:00","closed_at":"2026-01-13T11:09:58.874907-05:00","close_reason":"duplicate - superseded by new issues","dependencies":[{"issue_id":"liquid-il-ftc","depends_on_id":"liquid-il-o8d","type":"blocks","created_at":"2026-01-13T11:07:43.741118-05:00","created_by":"tobi"}]}
{"id":"liquid-il-hen","title":"Compiled: has_interrupt? on nil in recursive templates","description":"The compiled adapter errors with 'undefined method has_interrupt? for nil' when rendering recursive templates. The __scope__ variable is nil in some context during nested render/include calls. Tests affected: render_infinite_recursion, include_infinite_recursion, render_mutual_recursion, etc.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-14T21:16:02.910191-05:00","created_by":"tobi","updated_at":"2026-01-14T21:18:39.437554-05:00","closed_at":"2026-01-14T21:18:39.437554-05:00","close_reason":"Closed"}
{"id":"liquid-il-hpb","title":"Effect analysis infrastructure","description":"Build effect analysis infrastructure to track side effects of instructions (reads, writes, calls with side effects). Required foundation for dead store elimination, store forwarding, and code motion optimizations to be safe.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T11:09:43.782387-05:00","created_by":"tobi","updated_at":"2026-01-13T11:21:27.691197-05:00","closed_at":"2026-01-13T11:21:27.691197-05:00","close_reason":"Effect analysis infrastructure already fully implemented in lib/liquid_il/effect_analysis.rb (557 lines). Tracks reads/writes/side-effects for all IL instructions. Properly integrated via require in liquid_il.rb. Tests pass."}
{"id":"liquid-il-hxg","title":"Global linear scan register allocator","description":"Implement linear scan register allocation for temp slots.\n\n**Problem:**\n- Current STORE_TEMP/LOAD_TEMP uses arbitrary temp slot numbers\n- No coordination between different optimization passes\n- May use more temps than necessary\n\n**Linear scan algorithm:**\n- Build live ranges for all temps\n- Sort by start position\n- Allocate in linear order, spilling least-recently-used when needed\n- Minimize total temp slots used\n\n**Benefits:**\n- Reduces VM temp array size\n- Better cache locality\n- Enables Ruby compiler to use fewer local variables\n\n**Implementation:**\n- Liveness analysis pass (forward + backward)\n- Build live intervals\n- Linear scan allocation with spill handling\n- Rewrite temp slot numbers\n\n**Integration:**\n- Add as optimization pass in compiler.rb\n- Run late in pipeline (after other passes add temps)\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:07:29.239033-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.869713-05:00","closed_at":"2026-01-13T11:09:58.869713-05:00","close_reason":"duplicate - superseded by new issues","dependencies":[{"issue_id":"liquid-il-hxg","depends_on_id":"liquid-il-85q","type":"blocks","created_at":"2026-01-13T11:07:48.630319-05:00","created_by":"tobi"},{"issue_id":"liquid-il-hxg","depends_on_id":"liquid-il-ftc","type":"blocks","created_at":"2026-01-13T11:07:48.696537-05:00","created_by":"tobi"}]}
{"id":"liquid-il-i4j","title":"Use Set for control_flow_boundary? lookup","description":"**Problem:** `control_flow_boundary?` uses `case/when` for 14 opcodes, called per-instruction during optimization passes.\n\n**Profile evidence:** 3.8% of compile time.\n\n**Proposed improvement:** Use a frozen set for O(1) lookup:\n\n```ruby\nCONTROL_FLOW_OPCODES = [\n  IL::LABEL, IL::JUMP, IL::JUMP_IF_TRUE, # ...\n].to_set.freeze\n\ndef control_flow_boundary?(inst)\n  CONTROL_FLOW_OPCODES.include?(inst[0])\nend\n```\n\n**Implementation notes:**\n- Identify where control_flow_boundary? is defined\n- Replace case/when with Set lookup\n- Ensure set is frozen for thread safety","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-14T19:21:08.660922-05:00","created_by":"tobi","updated_at":"2026-01-14T19:35:55.443619-05:00","closed_at":"2026-01-14T19:35:55.443619-05:00","close_reason":"Replaced case/when with CONTROL_FLOW_OPCODES.to_set.freeze for O(1) lookup instead of O(n) sequential case matching"}
{"id":"liquid-il-jnd","title":"Ruby compiler: handle WRITE_VAR_PATH opcode","description":"The fuse_write_var pass (pass 20) creates WRITE_VAR_PATH opcodes that ruby_compiler.rb doesn't handle. Need to add a handler that generates efficient Ruby code for WRITE_VAR_PATH, similar to how FIND_VAR_PATH + WRITE_VALUE is handled.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-14T21:10:49.752078-05:00","created_by":"tobi","updated_at":"2026-01-14T21:12:48.379172-05:00","closed_at":"2026-01-14T21:12:48.379172-05:00","close_reason":"Closed"}
{"id":"liquid-il-o8d","title":"Effect analysis pass","description":"Implement effect analysis to classify instructions by their side effects (pure, reads-only, writes, I/O). This is foundational infrastructure used by many other passes.\n\n**Key effects to track:**\n- Pure: no observable side effects (const operations, arithmetic)\n- Reads: reads from context/variables\n- Writes: assigns to variables\n- I/O: writes output, calls filters with side effects\n\n**Implementation:**\n- Add effect classification for all 55 opcodes in IL\n- Create Effect enum or similar abstraction\n- Add methods: pure?, reads?, writes?, io?\n- Used by: value numbering, dead store elimination, store/load forwarding\n\n**Integration:**\n- Add to compiler.rb as helper module/class\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T11:06:36.044358-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.868129-05:00","closed_at":"2026-01-13T11:09:58.868129-05:00","close_reason":"duplicate - superseded by new issues"}
{"id":"liquid-il-oa0","title":"Partial inlining optimization pass","description":"Implement inlining for partial (include) calls where the partial template is statically known. Expand inline at compile time to eliminate call overhead and enable cross-template optimizations.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:09:40.270003-05:00","created_by":"tobi","updated_at":"2026-01-13T11:49:24.536078-05:00","closed_at":"2026-01-13T11:49:24.536078-05:00","close_reason":"Implemented inline_simple_partials optimization pass. Inlines RENDER_PARTIAL/INCLUDE_PARTIAL when: statically known name, no with/for modifiers, constant args only. Benchmarks show 1.17x speedup."}
{"id":"liquid-il-s73","title":"Escape analysis \u0026 scalar replacement","description":"Implement escape analysis to identify objects/values that don't escape their defining scope. Replace non-escaping aggregates with scalar values to eliminate allocation and enable register allocation of their fields.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:09:41.615483-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:41.615483-05:00"}
{"id":"liquid-il-s9l","title":"Cache find_max_temp_index result","description":"**Problem:** `find_max_temp_index` iterates all instructions and is called multiple times during compilation.\n\n**Profile evidence:** 6.3% of compile time.\n\n**Proposed improvement:** Compute once and cache, or track incrementally during IL generation:\n\n```ruby\n# Track during IL building\n@max_temp_index = -1\ndef emit_store_temp(idx)\n  @max_temp_index = [@max_temp_index, idx].max\n  emit(IL::STORE_TEMP, idx)\nend\n```\n\n**Implementation notes:**\n- Option A: Cache in IL object after first computation\n- Option B: Track incrementally during IL generation\n- Option B preferred if IL building is well-encapsulated","status":"in_progress","priority":1,"issue_type":"task","created_at":"2026-01-14T19:21:08.497691-05:00","created_by":"tobi","updated_at":"2026-01-14T19:21:56.237252-05:00"}
{"id":"liquid-il-wcp","title":"Dead store elimination pass","description":"Implement dead store elimination (DSE) to remove stores to variables that are never read.\n\n**Core algorithm:**\n- Backward dataflow analysis\n- Track which stores reach which uses\n- Remove stores with no reachable uses\n\n**Patterns to eliminate:**\n- ASSIGN x, val where x is reassigned before any read\n- ASSIGN x, val where x goes out of scope without read\n- STORE_TEMP slot where slot is never loaded\n\n**Key considerations:**\n- Must be conservative with escaping values\n- Variables passed to partials may escape\n- Loop variables must be handled carefully\n\n**Dependencies:**\n- Effect analysis (to identify stores vs other operations)\n\n**Integration:**\n- Add as optimization pass in compiler.rb\n- Tests should pass: rake test \u0026\u0026 rake spec","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T11:06:58.24679-05:00","created_by":"tobi","updated_at":"2026-01-13T11:09:58.87358-05:00","closed_at":"2026-01-13T11:09:58.87358-05:00","close_reason":"duplicate - superseded by new issues","dependencies":[{"issue_id":"liquid-il-wcp","depends_on_id":"liquid-il-o8d","type":"blocks","created_at":"2026-01-13T11:07:43.805327-05:00","created_by":"tobi"}]}
{"id":"liquid-il-wr6","title":"Skip ErrorMarker check for safe operations","description":"**Problem:** Every output expression includes `__v__.is_a?(LiquidIL::ErrorMarker) ? __v__.to_s : ...` even for operations that can't produce errors.\n\n**Current code:**\n```ruby\n__output__ \u003c\u003c (__v__ = __lookup_property__(__t0__, \"title\"); __v__.is_a?(LiquidIL::ErrorMarker) ? __v__.to_s : LiquidIL::Utils.output_string(__v__))\n```\n\n**Proposed improvement:** Track which operations can produce errors at compile time:\n\n```ruby\n# Property lookups never produce ErrorMarker\n__output__ \u003c\u003c LiquidIL::Utils.output_string(__lookup_property__(__t0__, \"title\"))\n\n# Filter calls can produce ErrorMarker - keep the check\n__output__ \u003c\u003c (__v__ = __call_filter__(...); __v__.is_a?(LiquidIL::ErrorMarker) ? __v__.to_s : LiquidIL::Utils.output_string(__v__))\n```\n\n**Implementation notes:**\n- Audit which IL operations can produce ErrorMarker\n- Add metadata to IL or track in code generator\n- Generate simplified output code for safe operations","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-14T19:21:08.828982-05:00","created_by":"tobi","updated_at":"2026-01-14T19:38:20.602736-05:00","closed_at":"2026-01-14T19:38:20.602736-05:00","close_reason":"Implemented can_error tracking in build_expression_chain. Operations without filters (lookups, property access) now generate direct LiquidIL::Utils.output_string() calls without the ErrorMarker type check. Filter calls retain the check since they can produce runtime errors.","labels":["ralph"]}
